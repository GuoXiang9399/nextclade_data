#!/usr/bin/env python3

"""
Builds a fresh data repo from source data
"""
import logging
from copy import deepcopy
from os.path import dirname, realpath, join, relpath
from os.path import isfile
from urllib.parse import quote

from lib.changelog import changelog_prepare
from lib.container import dict_get, dict_get_required, dict_set, unique, find_index_by, first, format_list
from lib.container import dict_remove_many, find_duplicates, dict_cleanup
from lib.date import now_iso, iso_to_iso_safe
from lib.fs import json_read, find_files, json_write, file_write, copy, make_zip
from lib.git import git_get_modified_files, git_dir_is_clean, git_get_dirty_files, git_check_tag, \
  git_get_initial_commit_hash, github_create_release, git_pull, git_commit_and_push

REPO = "neherlab/nextclade_data"
THIS_DIR = dirname(realpath(__file__))
PROJECT_ROOT_DIR = realpath(join(THIS_DIR, ".."))
DATA_INPUT_DIR = realpath(join(PROJECT_ROOT_DIR, "data_v3"))
DATA_OUTPUT_DIR = realpath(join(PROJECT_ROOT_DIR, "data_v3_output"))

logging.basicConfig(level=logging.INFO)
l = logging.getLogger(__file__)


def check_file(dataset_dir, filename):
  if isfile(join(dataset_dir, filename)):
    return filename
  return None


def get_dataset_capabilities(pathogen_json: dict, dataset_dir: str):
  reference_fasta_path = join(dataset_dir, "reference.fasta")
  if not isfile(reference_fasta_path):
    raise FileNotFoundError(f"Reference sequence must be present, but not found: {reference_fasta_path}")

  other = []
  tree_json_path = join(dataset_dir, "tree.json")
  has_tree_json = isfile(join(dataset_dir, "tree.json"))
  if has_tree_json:
    tree_json = json_read(tree_json_path)
    if dict_get(tree_json, ["extensions", "nextclade", "clade_node_attrs"]) is not None:
      other.append("customClades")

  if dict_get(pathogen_json, ["mutLabels"]) is not None:
    other.append("mutLabels")

  if dict_get(pathogen_json, ["phenotypeData"]) is not None:
    other.append("phenotypeData")

  if dict_get(pathogen_json, ["aaMotifs"]) is not None:
    other.append("aaMotifs")

  qc = []
  for k, q in (dict_get(pathogen_json, ["qc"]) or {}).items():
    if dict_get(q, ["enabled"]):
      qc.append(k)

  return dict_cleanup({
    "files": {
      "reference": "reference.fasta",
      "genomeAnnotation": check_file(dataset_dir, "genome_annotation.gff3"),
      "treeJson": check_file(dataset_dir, "tree.json"),
      "pathogenJson": check_file(dataset_dir, "pathogen.json"),
      "examples": check_file(dataset_dir, "sequences.fasta"),
      "readme": check_file(dataset_dir, "README.md"),
      "changelog": check_file(dataset_dir, "CHANGELOG.md"),
    },
    "qc": qc,
    "primers": True if len(dict_get(pathogen_json, ["primers"]) or []) > 0 else None,
    "other": other
  })


def index_one_dataset(pathogen_json_path: str, updated_at: str):
  pathogen_json = json_read(pathogen_json_path)
  dataset_dir = dirname(pathogen_json_path)
  path = relpath(dataset_dir, DATA_INPUT_DIR)

  dict_get_required(pathogen_json, ["attributes", "name", "value"])
  dict_get_required(pathogen_json, ["attributes", "name", "valueFriendly"])
  dict_get_required(pathogen_json, ["attributes", "reference", "value"])
  dict_get_required(pathogen_json, ["attributes", "reference", "valueFriendly"])

  return dict_cleanup({
    "path": path,
    "url": quote(path),
    "deprecated": True if dict_get(pathogen_json, ["deprecated"]) == True else None,
    "enabled": False if dict_get(pathogen_json, ["enabled"]) == False else None,
    "experimental": True if dict_get(pathogen_json, ["experimental"]) == True else None,
    "attributes": dict_get_required(pathogen_json, ["attributes"]),
    "capabilities": get_dataset_capabilities(pathogen_json, dataset_dir),
    "updatedAt": updated_at,
    # "schemaVersion": dict_get(pathogen_json, ["schemaVersion"]),
  })


def get_new_dataset_order(datasets, dataset_order):
  paths = list(map(lambda d: d["path"], datasets))

  dupes = find_duplicates(dataset_order)
  if len(dupes):
    raise ValueError(
      f"The '.dataset_order' list in 'collection.json' contains duplicated entries: {format_list(dupes)}. "
      f"Please make sure the entries are unique, to avoid ambiguity."
    )

  extra = set(dataset_order).difference(set(paths))
  if len(extra):
    raise ValueError(
      f"The '.dataset_order' list in 'collection.json' contains entries for datasets that are not found: "
      f"{format_list(extra)}. "
      f"Please double check the existence of datasets and the spelling of their paths in the '.dataset_order' list. "
      f"The full list of datasets that are found:\n  {format_list(paths)}."
    )

  missing = set(paths).difference(set(dataset_order))
  if len(missing):
    l.info(
      f"Adding '.dataset_order' entries to 'collection.json' for the following datasets: {format_list(missing)}. "
      f"Please reorder them manually as needed. This order is used when displaying datasets of the colelction in the user interface."
    )
    dataset_order += list(missing)
  return dataset_order


def sort_datasets(datasets, dataset_order):
  return [dataset for x in dataset_order for dataset in datasets if dataset["path"] == x]


def main():
  if not git_dir_is_clean():
    dirty_files = "\n  ".join(git_get_dirty_files())
    raise ValueError(
      f"Uncommited changes detected. Refusing to proceed. Commit or stash changes first:\n  {dirty_files}"
    )

  git_pull()

  updated_at = now_iso()
  tag = iso_to_iso_safe(updated_at)
  git_check_tag(tag)

  collection_json = json_read(join(DATA_INPUT_DIR, "collection.json"))

  datasets = []
  for pathogen_json_path in find_files("pathogen.json", DATA_INPUT_DIR):
    try:
      datasets.append(index_one_dataset(pathogen_json_path, updated_at))
    except Exception as e:
      raise ValueError(f"When processing '{pathogen_json_path}'") from e

  dataset_order = get_new_dataset_order(datasets, dict_get_required(collection_json, ["dataset_order"]) or [])
  datasets = sort_datasets(datasets, dataset_order)

  collection_json = {
    **collection_json,
    "dataset_order": dataset_order,
  }

  collection_info = deepcopy(collection_json)
  dict_remove_many(collection_info, ["dataset_order"])
  index_json = {
    **collection_info,
    "datasets": datasets,
    "updatedAt": updated_at,
    "schemaVersion": "3.0.0",
  }

  json_write(collection_json, join(DATA_INPUT_DIR, "collection.json"), no_sort_keys=True)

  release_infos = prepare_dataset_release_infos(datasets, tag, updated_at)

  if len(release_infos) == 0:
    l.info("No dataset modifications detected. Will not release anything.")
    return

  index_json_path = join(DATA_INPUT_DIR, "index.json")
  json_write({**index_json, "datasets": datasets, "updatedAt": updated_at}, index_json_path, no_sort_keys=True)

  release_notes = aggregate_release_notes(release_infos)

  create_release_package(release_notes)

  commit_hash = commit_changes(tag, release_infos)

  publish_to_github_releases(tag, commit_hash, release_notes)


def prepare_dataset_release_infos(datasets, tag, updated_at):
  release_infos = []
  for pathogen_json_path in find_files("pathogen.json", DATA_INPUT_DIR):
    dataset_dir = dirname(pathogen_json_path)
    dataset_dir_rel = relpath(dataset_dir, DATA_INPUT_DIR)

    i_dataset = find_index_by(lambda dataset: dataset["path"] == dataset_dir_rel, datasets)
    if i_dataset is None:
      raise ValueError(f"Dataset at '{dataset_dir_rel}' not found in the dataset index. Try to reindex datasets first.")

    dataset = datasets[i_dataset]
    versions = dict_get(dataset, ["versions"]) or []
    last_version = first(sorted(versions, reverse=True)) or git_get_initial_commit_hash()

    release_info = prepare_dataset_release_info(dataset_dir, dataset, last_version, updated_at)
    if release_info is None:
      continue

    release_infos.append(release_info)

    versions.insert(0, tag)
    dict_set(dataset, ["versions"], versions)
    dict_set(dataset, ["updatedAt"], updated_at)

    pathogen_json = json_read(pathogen_json_path)
    dict_set(pathogen_json, ["updatedAt"], updated_at)
    json_write(pathogen_json, pathogen_json_path, no_sort_keys=True)

    create_dataset_package(dataset, tag, dataset_dir)
  return release_infos


def aggregate_release_notes(release_infos):
  dataset_names_friendly = format_list(
    unique([get_dataset_name_friendly(release_info["dataset"]) for release_info in release_infos]),
    sep="\n", marker="- ", quote=False
  )
  release_notes = f"This release contains changes for datasets:\n\n{dataset_names_friendly}\n\n\n"
  for release_info in release_infos:
    release_notes += f'\n{release_info["release_notes"]}\n\n'
  return release_notes


def commit_changes(tag, release_infos):
  l.info(f"Commiting changes for '{tag}'")
  dataset_names = format_list(
    unique([get_dataset_name(release_info["dataset"]) for release_info in release_infos]),
    sep="\n", marker="- ", quote=False
  )
  return git_commit_and_push(commit_message=f"chore: release '{tag}'\n\nUpdated datasets:\n\n{dataset_names}")


def publish_to_github_releases(tag, commit_hash, release_notes):
  l.info(f"Publishing to GitHub Releases: tag: '{tag}', commit: '{commit_hash}'")
  release_files = list(find_files("*", join(DATA_OUTPUT_DIR, "github_releases")))
  github_create_release(
    repo=REPO,
    version=tag,
    commit_hash=commit_hash,
    release_notes=release_notes,
    files=release_files
  )


def prepare_dataset_release_info(dataset_dir, dataset, last_version, updated_at):
  modified_files = list(git_get_modified_files(from_revision=last_version, dirs=dataset_dir))

  if len(modified_files) == 0:
    return None

  path = dataset["path"]
  l.info(f"Preparing release of '{path}'")

  changelog_path = relpath(join(dataset_dir, "CHANGELOG.md"), PROJECT_ROOT_DIR)

  if changelog_path not in modified_files:
    raise ValueError(
      f"Cannot release dataset '{path}' without changelog. Please add or modify file '{changelog_path}': add '## Unreleased' section and briefly summarize the changes being released"
    )

  release_notes = changelog_prepare(dataset, updated_at, changelog_path)

  return {"dataset": dataset, "release_notes": release_notes, "dataset_dir": dataset_dir}


def create_release_package(release_notes):
  copy(join(DATA_INPUT_DIR, "index.json"), join(DATA_OUTPUT_DIR, "server/"))
  file_write(release_notes, join(DATA_OUTPUT_DIR, "github_releases", "CHANGELOG.md"))


def create_dataset_package(dataset, tag, dataset_dir):
  path = dataset["path"]
  files = dataset["capabilities"]["files"]
  out_dir = join(DATA_OUTPUT_DIR, "server", path, tag)
  for _, file in files.items():
    file = join(dataset_dir, file)
    copy(file, f"{out_dir}/")  # trailing slash is required if destination is a directory

  zip_basename = join(out_dir, "dataset")
  make_zip(dataset_dir, zip_basename)

  path_safe = path.replace("/", "__")
  copy(f"{zip_basename}.zip", join(DATA_OUTPUT_DIR, "github_releases", f"{path_safe}__{tag}.zip"))


def get_dataset_name(dataset):
  return dict_get_required(dataset, ["attributes", "name", "value"])


def get_dataset_name_friendly(dataset):
  return dict_get(dataset, ["attributes", "name", "valueFriendly"]) or get_dataset_name(dataset)


if __name__ == '__main__':
  main()
