#!/usr/bin/env python3

"""
Builds a fresh data repo from source data
"""
import argparse
import logging
from copy import deepcopy
from os import getcwd
from os.path import dirname, realpath, join, relpath, isfile
from urllib.parse import quote

from lib.changelog import changelog_prepare
from lib.container import dict_get, dict_get_required, dict_set, unique, find_index_by, first, format_list, \
  dict_remove_many, find_duplicates, dict_cleanup
from lib.date import now_iso, iso_to_iso_safe
from lib.fs import json_read, find_files, json_write, copy, make_zip
from lib.git import git_get_modified_files, git_dir_is_clean, git_get_dirty_files, git_check_tag, \
  git_get_initial_commit_hash, github_create_release, git_pull, git_commit_and_push

logging.basicConfig(level=logging.INFO)
l = logging.getLogger(__file__)


def get_dataset_capabilities(pathogen_json: dict, dataset_dir: str):
  reference_fasta_path = join(dataset_dir, "reference.fasta")
  if not isfile(reference_fasta_path):
    raise FileNotFoundError(f"Reference sequence must be present, but not found: {reference_fasta_path}")

  other = []
  tree_json_path = join(dataset_dir, "tree.json")
  has_tree_json = isfile(join(dataset_dir, "tree.json"))
  if has_tree_json:
    tree_json = json_read(tree_json_path)
    if dict_get(tree_json, ["extensions", "nextclade", "clade_node_attrs"]) is not None:
      other.append("customClades")

  if dict_get(pathogen_json, ["mutLabels"]) is not None:
    other.append("mutLabels")

  if dict_get(pathogen_json, ["phenotypeData"]) is not None:
    other.append("phenotypeData")

  if dict_get(pathogen_json, ["aaMotifs"]) is not None:
    other.append("aaMotifs")

  qc = []
  for k, q in (dict_get(pathogen_json, ["qc"]) or {}).items():
    if dict_get(q, ["enabled"]):
      qc.append(k)

  return dict_cleanup({
    "qc": qc,
    "primers": True if len(dict_get(pathogen_json, ["primers"]) or []) > 0 else None,
    "other": other
  })


def index_one_dataset(args, pathogen_json_path: str, updated_at: str):
  pathogen_json = json_read(pathogen_json_path)
  dataset_dir = dirname(pathogen_json_path)
  path = relpath(dataset_dir, args.input_dir)

  dict_get_required(pathogen_json, ["attributes", "name", "value"])
  dict_get_required(pathogen_json, ["attributes", "name", "valueFriendly"])
  dict_get_required(pathogen_json, ["attributes", "reference", "value"])
  dict_get_required(pathogen_json, ["attributes", "reference", "valueFriendly"])

  return dict_cleanup({
    "path": path,
    "url": quote(path),
    "deprecated": True if dict_get(pathogen_json, ["deprecated"]) == True else False,
    "enabled": False if dict_get(pathogen_json, ["enabled"]) == False else True,
    "experimental": True if dict_get(pathogen_json, ["experimental"]) == True else False,
    "attributes": dict_get_required(pathogen_json, ["attributes"]),
    "files": dict_get_required(pathogen_json, ["files"]),
    "capabilities": get_dataset_capabilities(pathogen_json, dataset_dir),
    "updatedAt": updated_at,
    # "schemaVersion": dict_get(pathogen_json, ["schemaVersion"]),
  })


def get_new_dataset_order(datasets, dataset_order):
  paths = list(map(lambda d: d["path"], datasets))

  dupes = find_duplicates(dataset_order)
  if len(dupes):
    raise ValueError(
      f"The '.dataset_order' list in 'collection.json' contains duplicated entries: {format_list(dupes)}. "
      f"Please make sure the entries are unique, to avoid ambiguity."
    )

  extra = set(dataset_order).difference(set(paths))
  if len(extra):
    raise ValueError(
      f"The '.dataset_order' list in 'collection.json' contains entries for datasets that are not found: "
      f"{format_list(extra)}. "
      f"Please double check the existence of datasets and the spelling of their paths in the '.dataset_order' list. "
      f"The full list of datasets that are found:\n  {format_list(paths)}."
    )

  missing = set(paths).difference(set(dataset_order))
  if len(missing):
    l.info(
      f"Adding '.dataset_order' entries to 'collection.json' for the following datasets: {format_list(missing)}. "
      f"Please reorder them manually as needed. This order is used when displaying datasets of the colelction in the "
      f"user interface."
    )
    dataset_order += list(missing)
  return dataset_order


def sort_datasets(datasets, dataset_order):
  return [dataset for x in dataset_order for dataset in datasets if dataset["path"] == x]


def parse_args():
  parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

  parser.add_argument('--input-dir', required=True, help='Directory of source files of a dataset collection')
  parser.add_argument('--output-dir', required=True, help='Where to output prepared files')
  parser.add_argument('--temp-dir', default=join(getcwd(), "data_v3_temp"),
                      help='Where to temporarily store release files')
  parser.add_argument('--allow-dirty', action='store_true',
                      help="Allow working directory to contain uncommited files. Note that these files will also be "
                           "commited and can potentially be released along with the datasets",
                      )
  parser.add_argument('--commit', action='store_true', help="Commit updates into the repository")
  parser.add_argument('--push', action='store_true', help="Push updates into the remote repository. Implies --commit")
  parser.add_argument('--release', action='store_true', help="Release updates. Implies --commit and --push")
  parser.add_argument('--repo', required=False,
                      help="GitHub repo to push and to release to. You need to have write permission for that."
                      )

  args = parser.parse_args()

  if args.push and not args.repo:
    parser.error("--push requires --repo")
  if args.release and not args.repo:
    parser.error("--release requires --repo")

  return args


def main():
  args = parse_args()

  if not args.allow_dirty and not git_dir_is_clean():
    dirty_files = "\n  ".join(git_get_dirty_files())
    raise ValueError(
      f"Uncommited changes detected. Refusing to proceed. Commit or stash changes first, or use --allow-dirty to "
      f"override (not recommended):\n  {dirty_files}"
    )

  git_pull()

  updated_at = now_iso()
  tag = iso_to_iso_safe(updated_at)
  git_check_tag(tag)

  collection_json = json_read(join(args.input_dir, "collection.json"))

  datasets = []
  for pathogen_json_path in find_files("pathogen.json", args.input_dir):
    try:
      datasets.append(index_one_dataset(args, pathogen_json_path, updated_at))
    except Exception as e:
      raise ValueError(f"When processing '{pathogen_json_path}'") from e

  dataset_order = get_new_dataset_order(datasets, dict_get_required(collection_json, ["dataset_order"]) or [])
  datasets = sort_datasets(datasets, dataset_order)

  collection_json = {
    **collection_json,
    "dataset_order": dataset_order,
  }

  collection_info = deepcopy(collection_json)
  dict_remove_many(collection_info, ["dataset_order"])
  dict_remove_many(collection_info, ["schemaVersion"])
  index_json = {
    "schemaVersion": "3.0.0",
    **collection_info,
    "datasets": datasets,
    "updatedAt": updated_at,
  }

  json_write(collection_json, join(args.input_dir, "collection.json"), no_sort_keys=True)

  release_infos = prepare_dataset_release_infos(args, datasets, tag, updated_at)

  if len(release_infos) == 0:
    l.info("No dataset modifications detected. Will not release anything.")
    return

  index_json_path = join(args.output_dir, "index.json")
  json_write({**index_json, "datasets": datasets, "updatedAt": updated_at}, index_json_path, no_sort_keys=True)

  if args.commit:
    commit_hash = commit_changes(tag, release_infos)

    if args.release:
      release_notes = aggregate_release_notes(release_infos)
      publish_to_github_releases(args, tag, commit_hash, release_notes)


def prepare_dataset_release_infos(args, datasets, tag, updated_at):
  release_infos = []
  for pathogen_json_path in find_files("pathogen.json", args.input_dir):
    dataset_dir = dirname(pathogen_json_path)
    dataset_dir_rel = relpath(dataset_dir, args.input_dir)

    i_dataset = find_index_by(lambda dataset: dataset["path"] == dataset_dir_rel, datasets)
    if i_dataset is None:
      raise ValueError(f"Dataset at '{dataset_dir_rel}' not found in the dataset index. Try to reindex datasets first.")

    dataset = datasets[i_dataset]
    versions = dict_get(dataset, ["versions"]) or []
    last_version = first(sorted(versions, reverse=True)) or git_get_initial_commit_hash()

    release_info = prepare_dataset_release_info(dataset_dir, dataset, last_version, updated_at)
    if release_info is None:
      continue

    release_infos.append(release_info)

    version = {"updatedAt": updated_at, "tag": tag}
    versions.insert(0, version)
    dict_set(dataset, ["versions"], versions)
    dict_set(dataset, ["version"], version)

    pathogen_json = json_read(pathogen_json_path)
    dict_set(pathogen_json, ["version"], version)
    json_write(pathogen_json, pathogen_json_path, no_sort_keys=True)

    create_dataset_package(args, dataset, pathogen_json, tag, dataset_dir)
  return release_infos


def aggregate_release_notes(release_infos):
  dataset_names_friendly = format_list(
    unique([get_dataset_name_friendly(release_info["dataset"]) for release_info in release_infos]),
    sep="\n", marker="- ", quote=False
  )
  release_notes = f"This release contains changes for datasets:\n\n{dataset_names_friendly}\n\n\n"
  for release_info in release_infos:
    release_notes += f'\n{release_info["release_notes"]}\n\n'
  return release_notes


def commit_changes(tag, release_infos):
  l.info(f"Commiting changes for '{tag}'")
  dataset_names = format_list(
    unique([get_dataset_name(release_info["dataset"]) for release_info in release_infos]),
    sep="\n", marker="- ", quote=False
  )
  return git_commit_and_push(commit_message=f"chore: release '{tag}'\n\nUpdated datasets:\n\n{dataset_names}")


def publish_to_github_releases(args, tag, commit_hash, release_notes):
  l.info(f"Publishing to GitHub Releases: tag: '{tag}', commit: '{commit_hash}'")
  release_files = list(find_files("*", join(args.temp_dir)))
  github_create_release(
    repo=args.repo,
    version=tag,
    commit_hash=commit_hash,
    release_notes=release_notes,
    files=release_files
  )


def prepare_dataset_release_info(dataset_dir, dataset, last_version, updated_at):
  modified_files = list(git_get_modified_files(from_revision=last_version, dirs=dataset_dir))
  modified_files = list(map(lambda f: realpath(f), modified_files))

  if len(modified_files) == 0:
    return None

  path = dataset["path"]
  l.info(f"Preparing release of '{path}'")

  changelog_path = join(dataset_dir, "CHANGELOG.md")

  if changelog_path not in modified_files:
    raise ValueError(
      f"Cannot release dataset '{path}' without changelog. Please add or modify file '{changelog_path}': add '## "
      f"Unreleased' section and briefly summarize the changes being released"
    )

  release_notes = changelog_prepare(dataset, updated_at, changelog_path)

  return {"dataset": dataset, "release_notes": release_notes, "dataset_dir": dataset_dir}


def create_dataset_package(args, dataset, pathogen_json, tag, dataset_dir):
  path = dataset["path"]
  files = pathogen_json["files"]

  dict_get_required(files, ["reference.fasta"])
  dict_get_required(files, ["pathogen.json"])

  out_dir = join(args.output_dir, path, tag)
  for _, file in files.items():
    file = join(dataset_dir, file)
    copy(file, f"{out_dir}/")  # trailing slash is required if destination is a directory

  zip_basename = join(out_dir, "dataset")
  make_zip(dataset_dir, zip_basename)

  path_safe = path.replace("/", "__")
  copy(f"{zip_basename}.zip", join(args.temp_dir, f"{path_safe}__{tag}.zip"))


def get_dataset_name(dataset):
  return dict_get_required(dataset, ["attributes", "name", "value"])


def get_dataset_name_friendly(dataset):
  return dict_get(dataset, ["attributes", "name", "valueFriendly"]) or get_dataset_name(dataset)


if __name__ == '__main__':
  main()
