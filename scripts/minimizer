#!/usr/bin/env python3

import numpy as np

from lib.fasta import fasta_read
from lib.minimizer import make_ref_search_index, preprocess_seq, get_ref_search_minimizers, invertible_hash

if __name__ == '__main__':
  refs = fasta_read('tests/minimizers/data/references.fasta')
  refs = {ref.name: ref for ref in refs}

  index = make_ref_search_index(refs)
  normalization = np.array([x['length'] / x['n_minimizers'] for x in index["references"]])

  overall_hits = np.zeros(len(index["references"]), dtype=np.int32)
  qrys = fasta_read('tests/minimizers/data/queries.fasta')
  for qry in qrys:
    seq_str = preprocess_seq(qry)
    minimizers = get_ref_search_minimizers(seq_str)
    hit_count = np.zeros(len(index["references"]), dtype=np.int32)
    for m in minimizers:
      if m in index["minimizers"]:
        hit_count += index["minimizers"][m]

    # we expect hits to be proportional to the length of the sequence and the number of minimizers per reference
    normalized_hits = normalization * hit_count / len(qry.seq)
    # require at least 30% of the maximal hits and at least 10 hits
    if np.max(normalized_hits) < 0.3 or np.sum(hit_count) < 10:
      print(qry.name, "no hit")
    else:
      overall_hits += normalized_hits > 0.3
      ri = np.argmax(normalized_hits)
      print(
        f"{qry.name}\t best hit={normalized_hits[ri]:1.2f} to reference "
        f"{index['references'][ri]['name']}")

  print("\nHits statistics:")
  for i, ref in enumerate(index["references"]):
    print(f"\t{ref['name']}\t{overall_hits[i]}")
  ## we could offer the user to run the analysis on these datasets in reverse order of the number of hits

  print(f"\nIndex statistics:")
  print(f"\tNumber of references: {len(index['references'])}")
  print(f"\tNumber of minimizers: {len(index['minimizers'])}")
  print(
    f"\tNumber of minimizers per kb: "
    f"{1000 * np.sum([x['n_minimizers'] for x in index['references']]) / np.sum([x['length'] for x in index['references']]):1.2f}")
  for ref in index["references"]:
    print(f"\t\t{ref['name']}\t{ref['n_minimizers']}")

  # check uniformity of hash function
  import matplotlib.pyplot as plt

  plt.figure()
  for start in range(0, 1 << 29, 1 << 22):
    # compute hashes for 2^12 integers starting at start
    hashes = [invertible_hash(x) for x in range(start, start + (1 << 12))]
    # sort and plot --> should be a straight line from 0 to 2^32-1
    plt.plot(sorted(hashes))
